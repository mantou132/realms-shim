{"version":3,"file":"realms-shim.cjs.js","sources":["../src/utilities.js","../src/realmFacade.js","../src/commons.js","../src/stdlib.js","../src/repair/accessors.js","../src/repair/functions.js","../src/unsafeRec.js","../src/optimizer.js","../src/scopeHandler.js","../src/sourceParser.js","../src/evaluators.js","../src/realm.js"],"sourcesContent":["// we'd like to abandon, but we can't, so just scream and break a lot of\n// stuff. However, since we aren't really aborting the process, be careful to\n// not throw an Error object which could be captured by child-Realm code and\n// used to access the (too-powerful) primal-realm Error object.\n\nexport function throwTantrum(s, err = undefined) {\n  const msg = `please report internal shim error: ${s}`;\n\n  // we want to log these 'should never happen' things.\n  // eslint-disable-next-line no-console\n  console.error(msg);\n  if (err) {\n    // eslint-disable-next-line no-console\n    console.error(`${err}`);\n    // eslint-disable-next-line no-console\n    console.error(`${err.stack}`);\n  }\n\n  // eslint-disable-next-line no-debugger\n  debugger;\n  throw msg;\n}\n\nexport function assert(condition, message) {\n  if (!condition) {\n    throwTantrum(message);\n  }\n}\n\n// Remove code modifications.\nexport function cleanupSource(src) {\n  /* START_TESTS_ONLY */\n\n  // Restore eval which is modified by esm module.\n  src = src.replace(/\\(0,[^)]+\\)/g, '(0, eval)');\n\n  // Remove code coverage which is injected by nyc module.\n  src = src.replace(/cov_[^+]+\\+\\+[;,]/g, '');\n\n  /* END_TESTS_ONLY */\n  return src;\n}\n","import { cleanupSource } from './utilities';\n\n// buildChildRealm is immediately turned into a string, and this function is\n// never referenced again, because it closes over the wrong intrinsics\n\nexport function buildChildRealm(unsafeRec, BaseRealm) {\n  const {\n    initRootRealm,\n    initCompartment,\n    getRealmGlobal,\n    realmEvaluate\n  } = BaseRealm;\n\n  // This Object and Reflect are brand new, from a new unsafeRec, so no user\n  // code has been run or had a chance to manipulate them. We extract these\n  // properties for brevity, not for security. Don't ever run this function\n  // *after* user code has had a chance to pollute its environment, or it\n  // could be used to gain access to BaseRealm and primal-realm Error\n  // objects.\n  const { create, defineProperties } = Object;\n\n  const errorConstructors = new Map([\n    ['EvalError', EvalError],\n    ['RangeError', RangeError],\n    ['ReferenceError', ReferenceError],\n    ['SyntaxError', SyntaxError],\n    ['TypeError', TypeError],\n    ['URIError', URIError]\n  ]);\n\n  // Like Realm.apply except that it catches anything thrown and rethrows it\n  // as an Error from this realm\n  function callAndWrapError(target, ...args) {\n    try {\n      return target(...args);\n    } catch (err) {\n      if (Object(err) !== err) {\n        // err is a primitive value, which is safe to rethrow\n        throw err;\n      }\n      let eName, eMessage, eStack;\n      try {\n        // The child environment might seek to use 'err' to reach the\n        // parent's intrinsics and corrupt them. `${err.name}` will cause\n        // string coercion of 'err.name'. If err.name is an object (probably\n        // a String of the parent Realm), the coercion uses\n        // err.name.toString(), which is under the control of the parent. If\n        // err.name were a primitive (e.g. a number), it would use\n        // Number.toString(err.name), using the child's version of Number\n        // (which the child could modify to capture its argument for later\n        // use), however primitives don't have properties like .prototype so\n        // they aren't useful for an attack.\n        eName = `${err.name}`;\n        eMessage = `${err.message}`;\n        eStack = `${err.stack || eMessage}`;\n        // eName/eMessage/eStack are now child-realm primitive strings, and\n        // safe to expose\n      } catch (ignored) {\n        // if err.name.toString() throws, keep the (parent realm) Error away\n        // from the child\n        throw new Error('unknown error');\n      }\n      const ErrorConstructor = errorConstructors.get(eName) || Error;\n      try {\n        throw new ErrorConstructor(eMessage);\n      } catch (err2) {\n        err2.stack = eStack; // replace with the captured inner stack\n        throw err2;\n      }\n    }\n  }\n\n  class Realm {\n    constructor() {\n      // The Realm constructor is not intended to be used with the new operator\n      // or to be subclassed. It may be used as the value of an extends clause\n      // of a class definition but a super call to the Realm constructor will\n      // cause an exception.\n\n      // When Realm is called as a function, an exception is also raised because\n      // a class constructor cannot be invoked without 'new'.\n      throw new TypeError('Realm is not a constructor');\n    }\n\n    static makeRootRealm(options = {}) {\n      // This is the exposed interface.\n\n      // Bypass the constructor.\n      const r = create(Realm.prototype);\n      callAndWrapError(initRootRealm, unsafeRec, r, options);\n      return r;\n    }\n\n    static makeCompartment(options = {}) {\n      // Bypass the constructor.\n      const r = create(Realm.prototype);\n      callAndWrapError(initCompartment, unsafeRec, r, options);\n      return r;\n    }\n\n    // we omit the constructor because it is empty. All the personalization\n    // takes place in one of the two static methods,\n    // makeRootRealm/makeCompartment\n\n    get global() {\n      // this is safe against being called with strange 'this' because\n      // baseGetGlobal immediately does a trademark check (it fails unless\n      // this 'this' is present in a weakmap that is only populated with\n      // legitimate Realm instances)\n      return callAndWrapError(getRealmGlobal, this);\n    }\n\n    evaluate(x, endowments, options = {}) {\n      // safe against strange 'this', as above\n      return callAndWrapError(realmEvaluate, this, x, endowments, options);\n    }\n  }\n\n  defineProperties(Realm, {\n    toString: {\n      value: () => 'function Realm() { [shim code] }',\n      writable: false,\n      enumerable: false,\n      configurable: true\n    }\n  });\n\n  defineProperties(Realm.prototype, {\n    toString: {\n      value: () => '[object Realm]',\n      writable: false,\n      enumerable: false,\n      configurable: true\n    }\n  });\n\n  return Realm;\n}\n\n// The parentheses means we don't bind the 'buildChildRealm' name inside the\n// child's namespace. this would accept an anonymous function declaration.\n// function expression (not a declaration) so it has a completion value.\nconst buildChildRealmString = cleanupSource(\n  `'use strict'; (${buildChildRealm})`\n);\n\nexport function createRealmFacade(unsafeRec, BaseRealm) {\n  const { unsafeEval } = unsafeRec;\n\n  // The BaseRealm is the Realm class created by\n  // the shim. It's only valid for the context where\n  // it was parsed.\n\n  // The Realm facade is a lightweight class built in the\n  // context a different context, that provide a fully\n  // functional Realm class using the intrisics\n  // of that context.\n\n  // This process is simplified because all methods\n  // and properties on a realm instance already return\n  // values using the intrinsics of the realm's context.\n\n  // Invoke the BaseRealm constructor with Realm as the prototype.\n  return unsafeEval(buildChildRealmString)(unsafeRec, BaseRealm);\n}\n","// Declare shorthand functions. Sharing these declarations across modules\n// improves both consistency and minification. Unused declarations are\n// dropped by the tree shaking process.\n\n// we capture these, not just for brevity, but for security. If any code\n// modifies Object to change what 'assign' points to, the Realm shim would be\n// corrupted.\n\nexport const {\n  assign,\n  create,\n  freeze,\n  defineProperties, // Object.defineProperty is allowed to fail\n  // silentlty, use Object.defineProperties instead.\n  getOwnPropertyDescriptor,\n  getOwnPropertyDescriptors,\n  getOwnPropertyNames,\n  getPrototypeOf,\n  setPrototypeOf\n} = Object;\n\nexport const {\n  apply,\n  ownKeys // Reflect.ownKeys includes Symbols and unenumerables,\n  // unlike Object.keys()\n} = Reflect;\n\n/**\n * uncurryThis() See\n * http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming\n * which only lives at\n * http://web.archive.org/web/20160805225710/http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming\n *\n * Performance:\n * 1. The native call is about 10x faster on FF than chrome\n * 2. The version using Function.bind() is about 100x slower on FF,\n *    equal on chrome, 2x slower on Safari\n * 3. The version using a spread and Reflect.apply() is about 10x\n *    slower on FF, equal on chrome, 2x slower on Safari\n *\n * const bind = Function.prototype.bind;\n * const uncurryThis = bind.bind(bind.call);\n */\nconst uncurryThis = fn => (thisArg, ...args) => apply(fn, thisArg, args);\n\n// We also capture these for security: changes to Array.prototype after the\n// Realm shim runs shouldn't affect subsequent Realm operations.\nexport const objectHasOwnProperty = uncurryThis(\n    Object.prototype.hasOwnProperty\n  ),\n  arrayForEach = uncurryThis(Array.prototype.forEach),\n  arrayFilter = uncurryThis(Array.prototype.filter),\n  arrayPush = uncurryThis(Array.prototype.push),\n  arrayPop = uncurryThis(Array.prototype.pop),\n  arrayJoin = uncurryThis(Array.prototype.join),\n  arrayConcat = uncurryThis(Array.prototype.concat),\n  regexpTest = uncurryThis(RegExp.prototype.test),\n  stringMatch = uncurryThis(String.prototype.match),\n  stringIncludes = uncurryThis(String.prototype.includes);\n","import { getOwnPropertyDescriptor } from './commons';\nimport { assert } from './utilities';\n\n// These value properties of the global object are non-writable,\n// non-configurable data properties.\nconst frozenGlobalPropertyNames = [\n  // *** 18.1 Value Properties of the Global Object\n\n  'Infinity',\n  'NaN',\n  'undefined'\n];\n\n// All the following stdlib items have the same name on both our intrinsics\n// object and on the global object. Unlike Infinity/NaN/undefined, these\n// should all be writable and configurable. This is divided into two\n// sets. The stable ones are those the shim can freeze early because\n// we don't expect anyone will want to mutate them. The unstable ones\n// are the ones that we correctly initialize to writable and\n// configurable so that they can still be replaced or removed.\nconst stableGlobalPropertyNames = [\n  // *** 18.2 Function Properties of the Global Object\n\n  // 'eval', // comes from safeEval instead\n  'isFinite',\n  'isNaN',\n  'parseFloat',\n  'parseInt',\n\n  'decodeURI',\n  'decodeURIComponent',\n  'encodeURI',\n  'encodeURIComponent',\n\n  // *** 18.3 Constructor Properties of the Global Object\n\n  'Array',\n  'ArrayBuffer',\n  'Boolean',\n  'DataView',\n  // 'Date',  // Unstable\n  // 'Error',  // Unstable\n  'EvalError',\n  'Float32Array',\n  'Float64Array',\n  // 'Function',  // comes from safeFunction instead\n  'Int8Array',\n  'Int16Array',\n  'Int32Array',\n  'Map',\n  'Number',\n  'Object',\n  // 'Promise',  // Unstable\n  // 'Proxy',  // Unstable\n  'RangeError',\n  'ReferenceError',\n  // 'RegExp',  // Unstable\n  'Set',\n  // 'SharedArrayBuffer'  // removed on Jan 5, 2018\n  'String',\n  'Symbol',\n  'SyntaxError',\n  'TypeError',\n  'Uint8Array',\n  'Uint8ClampedArray',\n  'Uint16Array',\n  'Uint32Array',\n  'URIError',\n  'WeakMap',\n  'WeakSet',\n\n  // *** 18.4 Other Properties of the Global Object\n\n  // 'Atomics', // removed on Jan 5, 2018\n  'JSON',\n  'Math',\n  'Reflect',\n\n  // *** Annex B\n\n  'escape',\n  'unescape'\n\n  // *** ECMA-402\n\n  // 'Intl'  // Unstable\n\n  // *** ESNext\n\n  // 'Realm' // Comes from createRealmGlobalObject()\n];\n\nconst unstableGlobalPropertyNames = [\n  'Date',\n  'Error',\n  'Promise',\n  'Proxy',\n  'RegExp',\n  'Intl'\n];\n\nexport function getSharedGlobalDescs(unsafeGlobal) {\n  const descriptors = {};\n\n  function describe(names, writable, enumerable, configurable) {\n    for (const name of names) {\n      const desc = getOwnPropertyDescriptor(unsafeGlobal, name);\n      if (desc) {\n        // Abort if an accessor is found on the unsafe global object\n        // instead of a data property. We should never get into this\n        // non standard situation.\n        assert(\n          'value' in desc,\n          `unexpected accessor on global property: ${name}`\n        );\n\n        descriptors[name] = {\n          value: desc.value,\n          writable,\n          enumerable,\n          configurable\n        };\n      }\n    }\n  }\n\n  describe(frozenGlobalPropertyNames, false, false, false);\n  // The following is correct but expensive.\n  // describe(stableGlobalPropertyNames, true, false, true);\n  // Instead, for now, we let these get optimized.\n  //\n  // TODO: We should provide an option to turn this optimization off,\n  // by feeding \"true, false, true\" here instead.\n  describe(stableGlobalPropertyNames, false, false, false);\n  // These we keep replaceable and removable, because we expect\n  // others, e.g., SES, may want to do so.\n  describe(unstableGlobalPropertyNames, true, false, true);\n\n  return descriptors;\n}\n","// Adapted from SES/Caja - Copyright (C) 2011 Google Inc.\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/startSES.js\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/repairES5.js\n\n/**\n * Replace the legacy accessors of Object to comply with strict mode\n * and ES2016 semantics, we do this by redefining them while in 'use strict'.\n *\n * todo: list the issues resolved\n *\n * This function can be used in two ways: (1) invoked directly to fix the primal\n * realm's Object.prototype, and (2) converted to a string to be executed\n * inside each new RootRealm to fix their Object.prototypes. Evaluation requires\n * the function to have no dependencies, so don't import anything from\n * the outside.\n */\n\n// todo: this file should be moved out to a separate repo and npm module.\nexport function repairAccessors() {\n  const {\n    defineProperty,\n    defineProperties,\n    getOwnPropertyDescriptor,\n    getPrototypeOf,\n    prototype: objectPrototype\n  } = Object;\n\n  // On some platforms, the implementation of these functions act as\n  // if they are in sloppy mode: if they're invoked badly, they will\n  // expose the global object, so we need to repair these for\n  // security. Thus it is our responsibility to fix this, and we need\n  // to include repairAccessors. E.g. Chrome in 2016.\n\n  try {\n    // Verify that the method is not callable.\n    // eslint-disable-next-line no-restricted-properties, no-underscore-dangle\n    (0, objectPrototype.__lookupGetter__)('x');\n  } catch (ignore) {\n    // Throws, no need to patch.\n    return;\n  }\n\n  function toObject(obj) {\n    if (obj === undefined || obj === null) {\n      throw new TypeError(`can't convert undefined or null to object`);\n    }\n    return Object(obj);\n  }\n\n  function asPropertyName(obj) {\n    if (typeof obj === 'symbol') {\n      return obj;\n    }\n    return `${obj}`;\n  }\n\n  function aFunction(obj, accessor) {\n    if (typeof obj !== 'function') {\n      throw TypeError(`invalid ${accessor} usage`);\n    }\n    return obj;\n  }\n\n  defineProperties(objectPrototype, {\n    __defineGetter__: {\n      value: function __defineGetter__(prop, func) {\n        const O = toObject(this);\n        defineProperty(O, prop, {\n          get: aFunction(func, 'getter'),\n          enumerable: true,\n          configurable: true\n        });\n      }\n    },\n    __defineSetter__: {\n      value: function __defineSetter__(prop, func) {\n        const O = toObject(this);\n        defineProperty(O, prop, {\n          set: aFunction(func, 'setter'),\n          enumerable: true,\n          configurable: true\n        });\n      }\n    },\n    __lookupGetter__: {\n      value: function __lookupGetter__(prop) {\n        let O = toObject(this);\n        prop = asPropertyName(prop);\n        let desc;\n        while (O && !(desc = getOwnPropertyDescriptor(O, prop))) {\n          O = getPrototypeOf(O);\n        }\n        return desc && desc.get;\n      }\n    },\n    __lookupSetter__: {\n      value: function __lookupSetter__(prop) {\n        let O = toObject(this);\n        prop = asPropertyName(prop);\n        let desc;\n        while (O && !(desc = getOwnPropertyDescriptor(O, prop))) {\n          O = getPrototypeOf(O);\n        }\n        return desc && desc.set;\n      }\n    }\n  });\n}\n","// Adapted from SES/Caja\n// Copyright (C) 2011 Google Inc.\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/startSES.js\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/repairES5.js\n\n/**\n * This block replaces the original Function constructor, and the original\n * %GeneratorFunction% %AsyncFunction% and %AsyncGeneratorFunction%, with\n * safe replacements that throw if invoked.\n *\n * These are all reachable via syntax, so it isn't sufficient to just\n * replace global properties with safe versions. Our main goal is to prevent\n * access to the Function constructor through these starting points.\n\n * After this block is done, the originals must no longer be reachable, unless\n * a copy has been made, and funtions can only be created by syntax (using eval)\n * or by invoking a previously saved reference to the originals.\n */\n\n// todo: this file should be moved out to a separate repo and npm module.\nexport function repairFunctions() {\n  const { defineProperties, getPrototypeOf, setPrototypeOf } = Object;\n\n  /**\n   * The process to repair constructors:\n   * 1. Create an instance of the function by evaluating syntax\n   * 2. Obtain the prototype from the instance\n   * 3. Create a substitute tamed constructor\n   * 4. Replace the original constructor with the tamed constructor\n   * 5. Replace tamed constructor prototype property with the original one\n   * 6. Replace its [[Prototype]] slot with the tamed constructor of Function\n   */\n  function repairFunction(name, declaration) {\n    let FunctionInstance;\n    try {\n      // eslint-disable-next-line no-new-func\n      FunctionInstance = (0, eval)(declaration);\n    } catch (e) {\n      if (e instanceof SyntaxError) {\n        // Prevent failure on platforms where async and/or generators\n        // are not supported.\n        return;\n      }\n      // Re-throw\n      throw e;\n    }\n    const FunctionPrototype = getPrototypeOf(FunctionInstance);\n\n    // Prevents the evaluation of source when calling constructor on the\n    // prototype of functions.\n    const TamedFunction = function() {\n      throw new TypeError('Not available');\n    };\n    defineProperties(TamedFunction, { name: { value: name } });\n\n    // (new Error()).constructors does not inherit from Function, because Error\n    // was defined before ES6 classes. So we don't need to repair it too.\n\n    // (Error()).constructor inherit from Function, which gets a tamed\n    // constructor here.\n\n    // todo: in an ES6 class that does not inherit from anything, what does its\n    // constructor inherit from? We worry that it inherits from Function, in\n    // which case instances could give access to unsafeFunction. markm says\n    // we're fine: the constructor inherits from Object.prototype\n\n    // This line replaces the original constructor in the prototype chain\n    // with the tamed one. No copy of the original is peserved.\n    defineProperties(FunctionPrototype, {\n      constructor: { value: TamedFunction }\n    });\n\n    // This line sets the tamed constructor's prototype data property to\n    // the original one.\n    defineProperties(TamedFunction, {\n      prototype: { value: FunctionPrototype }\n    });\n\n    if (TamedFunction !== Function.prototype.constructor) {\n      // Ensures that all functions meet \"instanceof Function\" in a realm.\n      setPrototypeOf(TamedFunction, Function.prototype.constructor);\n    }\n  }\n\n  // Here, the order of operation is important: Function needs to be repaired\n  // first since the other repaired constructors need to inherit from the tamed\n  // Function function constructor.\n\n  // note: this really wants to be part of the standard, because new\n  // constructors may be added in the future, reachable from syntax, and this\n  // list must be updated to match.\n\n  // \"plain arrow functions\" inherit from Function.prototype\n\n  repairFunction('Function', '(function(){})');\n  repairFunction('GeneratorFunction', '(function*(){})');\n  repairFunction('AsyncFunction', '(async function(){})');\n  repairFunction('AsyncGeneratorFunction', '(async function*(){})');\n}\n","// this module must never be importable outside the Realm shim itself\nimport { getSharedGlobalDescs } from './stdlib';\nimport { repairAccessors } from './repair/accessors';\nimport { repairFunctions } from './repair/functions';\nimport { cleanupSource } from './utilities';\nimport { freeze } from './commons';\n\n// A \"context\" is a fresh unsafe Realm as given to us by existing platforms.\n// We need this to implement the shim. However, when Realms land for real,\n// this feature will be provided by the underlying engine instead.\n\n// note: in a node module, the top-level 'this' is not the global object\n// (it's *something* but we aren't sure what), however an indirect eval of\n// 'this' will be the correct global object.\n\nconst unsafeGlobalSrc = \"'use strict'; this\";\nconst unsafeGlobalEvalSrc = `(0, eval)(\"'use strict'; this\")`;\n\n// This method is only exported for testing purposes.\nexport function createNewUnsafeGlobalForNode() {\n  // Note that webpack and others will shim 'vm' including the method\n  // 'runInNewContext', so the presence of vm is not a useful check\n\n  // TODO: Find a better test that works with bundlers\n  // eslint-disable-next-line no-new-func\n  const isNode = new Function(\n    'try {return this===global}catch(e){return false}'\n  )();\n\n  if (!isNode) {\n    return undefined;\n  }\n\n  // eslint-disable-next-line global-require\n  const vm = require('vm');\n\n  // Use unsafeGlobalEvalSrc to ensure we get the right 'this'.\n  const unsafeGlobal = vm.runInNewContext(unsafeGlobalEvalSrc);\n\n  return unsafeGlobal;\n}\n\n// This method is only exported for testing purposes.\nexport function createNewUnsafeGlobalForBrowser() {\n  if (typeof document === 'undefined') {\n    return undefined;\n  }\n  const iframe = document.createElement('iframe');\n  iframe.style.display = 'none';\n\n  document.body.appendChild(iframe);\n  const unsafeGlobal = iframe.contentWindow.eval(unsafeGlobalSrc);\n\n  // We keep the iframe attached to the DOM because removing it\n  // causes its global object to lose intrinsics, its eval()\n  // function to evaluate code, etc.\n\n  // TODO: can we remove and garbage-collect the iframes?\n\n  return unsafeGlobal;\n}\n\nconst getNewUnsafeGlobal = () => {\n  const newUnsafeGlobalForBrowser = createNewUnsafeGlobalForBrowser();\n  const newUnsafeGlobalForNode = createNewUnsafeGlobalForNode();\n  if (\n    (!newUnsafeGlobalForBrowser && !newUnsafeGlobalForNode) ||\n    (newUnsafeGlobalForBrowser && newUnsafeGlobalForNode)\n  ) {\n    throw new Error('unexpected platform, unable to create Realm');\n  }\n  return newUnsafeGlobalForBrowser || newUnsafeGlobalForNode;\n};\n\n// The unsafeRec is shim-specific. It acts as the mechanism to obtain a fresh\n// set of intrinsics together with their associated eval and Function\n// evaluators. These must be used as a matched set, since the evaluators are\n// tied to a set of intrinsics, aka the \"undeniables\". If it were possible to\n// mix-and-match them from different contexts, that would enable some\n// attacks.\nfunction createUnsafeRec(unsafeGlobal, allShims = []) {\n  const sharedGlobalDescs = getSharedGlobalDescs(unsafeGlobal);\n\n  return freeze({\n    unsafeGlobal,\n    sharedGlobalDescs,\n    unsafeEval: unsafeGlobal.eval,\n    unsafeFunction: unsafeGlobal.Function,\n    allShims\n  });\n}\n\nconst repairAccessorsShim = cleanupSource(\n  `\"use strict\"; (${repairAccessors})();`\n);\nconst repairFunctionsShim = cleanupSource(\n  `\"use strict\"; (${repairFunctions})();`\n);\n\n// Create a new unsafeRec from a brand new context, with new intrinsics and a\n// new global object\nexport function createNewUnsafeRec(allShims) {\n  const unsafeGlobal = getNewUnsafeGlobal();\n  unsafeGlobal.eval(repairAccessorsShim);\n  unsafeGlobal.eval(repairFunctionsShim);\n  return createUnsafeRec(unsafeGlobal, allShims);\n}\n\n// Create a new unsafeRec from the current context, where the Realm shim is\n// being parsed and executed, aka the \"Primal Realm\"\nexport function createCurrentUnsafeRec() {\n  const unsafeGlobal = (0, eval)(unsafeGlobalSrc);\n  repairAccessors();\n  repairFunctions();\n  return createUnsafeRec(unsafeGlobal);\n}\n","import {\n  arrayFilter,\n  getOwnPropertyDescriptors,\n  getOwnPropertyNames,\n  objectHasOwnProperty,\n  regexpTest\n} from './commons';\n\n// todo: think about how this interacts with endowments, check for conflicts\n// between the names being optimized and the ones added by endowments\n\n/**\n * Simplified validation of indentifier names: may only contain alphanumeric\n * characters (or \"$\" or \"_\"), and may not start with a digit. This is safe\n * and does not reduces the compatibility of the shim. The motivation for\n * this limitation was to decrease the complexity of the implementation,\n * and to maintain a resonable level of performance.\n * Note: \\w is equivalent [a-zA-Z_0-9]\n * See 11.6.1 Identifier Names\n */\nconst identifierPattern = /^[a-zA-Z_$][\\w$]*$/;\n\n/**\n * In JavaScript you cannot use these reserved words as variables.\n * See 11.6.1 Identifier Names\n */\nconst keywords = new Set([\n  // 11.6.2.1 Keywords\n  'await',\n  'break',\n  'case',\n  'catch',\n  'class',\n  'const',\n  'continue',\n  'debugger',\n  'default',\n  'delete',\n  'do',\n  'else',\n  'export',\n  'extends',\n  'finally',\n  'for',\n  'function',\n  'if',\n  'import',\n  'in',\n  'instanceof',\n  'new',\n  'return',\n  'super',\n  'switch',\n  'this',\n  'throw',\n  'try',\n  'typeof',\n  'var',\n  'void',\n  'while',\n  'with',\n  'yield',\n\n  // Also reserved when parsing strict mode code\n  'let',\n  'static',\n\n  // 11.6.2.2 Future Reserved Words\n  'enum',\n\n  // Also reserved when parsing strict mode code\n  'implements',\n  'package',\n  'protected',\n  'interface',\n  'private',\n  'public',\n\n  // Reserved but not mentioned in specs\n  'await',\n\n  'null',\n  'true',\n  'false',\n\n  'this',\n  'arguments'\n]);\n\n/**\n * getOptimizableGlobals()\n * What variable names might it bring into scope? These include all\n * property names which can be variable names, including the names\n * of inherited properties. It excludes symbols and names which are\n * keywords. We drop symbols safely. Currently, this shim refuses\n * service if any of the names are keywords or keyword-like. This is\n * safe and only prevent performance optimization.\n */\nexport function getOptimizableGlobals(safeGlobal) {\n  const descs = getOwnPropertyDescriptors(safeGlobal);\n\n  // getOwnPropertyNames does ignore Symbols so we don't need this extra check:\n  // typeof name === 'string' &&\n  const constants = arrayFilter(getOwnPropertyNames(descs), name => {\n    // Ensure we have a valid identifier. We use regexpTest rather than\n    // /../.test() to guard against the case where RegExp has been poisoned.\n    if (\n      name === 'eval' ||\n      keywords.has(name) ||\n      !regexpTest(identifierPattern, name)\n    ) {\n      return false;\n    }\n\n    const desc = descs[name];\n    return (\n      //\n      // The getters will not have .writable, don't let the falsyness of\n      // 'undefined' trick us: test with === false, not ! . However descriptors\n      // inherit from the (potentially poisoned) global object, so we might see\n      // extra properties which weren't really there. Accessor properties have\n      // 'get/set/enumerable/configurable', while data properties have\n      // 'value/writable/enumerable/configurable'.\n      desc.configurable === false &&\n      desc.writable === false &&\n      //\n      // Checks for data properties because they're the only ones we can\n      // optimize (accessors are most likely non-constant). Descriptors can't\n      // can't have accessors and value properties at the same time, therefore\n      // this check is sufficient. Using explicit own property deal with the\n      // case where Object.prototype has been poisoned.\n      objectHasOwnProperty(desc, 'value')\n    );\n  });\n\n  return constants;\n}\n","import { freeze, objectHasOwnProperty } from './commons';\nimport { throwTantrum } from './utilities';\n\n/**\n * alwaysThrowHandler is a proxy handler which throws on any trap called.\n * It's made from a proxy with a get trap that throws. Its target is\n * an immutable (frozen) object and is safe to share.\n */\nconst alwaysThrowHandler = new Proxy(freeze({}), {\n  get(target, prop) {\n    throwTantrum(`unexpected scope handler trap called: ${prop}`);\n  }\n});\n\n/**\n * ScopeHandler manages a Proxy which serves as the global scope for the\n * safeEvaluator operation (the Proxy is the argument of a 'with' binding).\n * As described in createSafeEvaluator(), it has several functions:\n * - allow the very first (and only the very first) use of 'eval' to map to\n *   the real (unsafe) eval function, so it acts as a 'direct eval' and can\n *    access its lexical scope (which maps to the 'with' binding, which the\n *   ScopeHandler also controls).\n * - ensure that all subsequent uses of 'eval' map to the safeEvaluator,\n *   which lives as the 'eval' property of the safeGlobal.\n * - route all other property lookups at the safeGlobal.\n * - hide the unsafeGlobal which lives on the scope chain above the 'with'.\n * - ensure the Proxy invariants despite some global properties being frozen.\n */\nexport function createScopeHandler(unsafeRec, safeGlobal, sloppyGlobals) {\n  const { unsafeGlobal, unsafeEval } = unsafeRec;\n\n  // This flag allow us to determine if the eval() call is an done by the\n  // realm's code or if it is user-land invocation, so we can react differently.\n  let useUnsafeEvaluator = false;\n\n  return {\n    // The scope handler throws if any trap other than get/set/has are run\n    // (e.g. getOwnPropertyDescriptors, apply, getPrototypeOf).\n    // eslint-disable-next-line no-proto\n    __proto__: alwaysThrowHandler,\n\n    allowUnsafeEvaluatorOnce() {\n      useUnsafeEvaluator = true;\n    },\n\n    unsafeEvaluatorAllowed() {\n      return useUnsafeEvaluator;\n    },\n\n    get(target, prop) {\n      // Special treatment for eval. The very first lookup of 'eval' gets the\n      // unsafe (real direct) eval, so it will get the lexical scope that uses\n      // the 'with' context.\n      if (prop === 'eval') {\n        // test that it is true rather than merely truthy\n        if (useUnsafeEvaluator === true) {\n          // revoke before use\n          useUnsafeEvaluator = false;\n          return unsafeEval;\n        }\n        return target.eval;\n      }\n\n      // todo: shim integrity, capture Symbol.unscopables\n      if (prop === Symbol.unscopables) {\n        // Safe to return a primal realm Object here because the only code that\n        // can do a get() on a non-string is the internals of with() itself,\n        // and the only thing it does is to look for properties on it. User\n        // code cannot do a lookup on non-strings.\n        return undefined;\n      }\n\n      // Properties of the global.\n      if (prop in target) {\n        return target[prop];\n      }\n\n      // Prevent the lookup for other properties.\n      return undefined;\n    },\n\n    // eslint-disable-next-line class-methods-use-this\n    set(target, prop, value) {\n      // todo: allow modifications when target.hasOwnProperty(prop) and it\n      // is writable, assuming we've already rejected overlap (see\n      // createSafeEvaluatorFactory.factory). This TypeError gets replaced with\n      // target[prop] = value\n      if (objectHasOwnProperty(target, prop)) {\n        // todo: shim integrity: TypeError, String\n        throw new TypeError(`do not modify endowments like ${String(prop)}`);\n      }\n\n      safeGlobal[prop] = value;\n\n      // Return true after successful set.\n      return true;\n    },\n\n    // we need has() to return false for some names to prevent the lookup  from\n    // climbing the scope chain and eventually reaching the unsafeGlobal\n    // object, which is bad.\n\n    // note: unscopables! every string in Object[Symbol.unscopables]\n\n    // todo: we'd like to just have has() return true for everything, and then\n    // use get() to raise a ReferenceError for anything not on the safe global.\n    // But we want to be compatible with ReferenceError in the normal case and\n    // the lack of ReferenceError in the 'typeof' case. Must either reliably\n    // distinguish these two cases (the trap behavior might be different), or\n    // we rely on a mandatory source-to-source transform to change 'typeof abc'\n    // to XXX. We already need a mandatory parse to prevent the 'import',\n    // since it's a special form instead of merely being a global variable/\n\n    // note: if we make has() return true always, then we must implement a\n    // set() trap to avoid subverting the protection of strict mode (it would\n    // accept assignments to undefined globals, when it ought to throw\n    // ReferenceError for such assignments)\n\n    has(target, prop) {\n      // proxies stringify 'prop', so no TOCTTOU danger here\n\n      if (sloppyGlobals) {\n        // Everything is potentially available.\n        return true;\n      }\n\n      // unsafeGlobal: hide all properties of unsafeGlobal at the\n      // expense of 'typeof' being wrong for those properties. For\n      // example, in the browser, evaluating 'document = 3', will add\n      // a property to safeGlobal instead of throwing a\n      // ReferenceError.\n      if (prop === 'eval' || prop in target || prop in unsafeGlobal) {\n        return true;\n      }\n\n      return false;\n    }\n  };\n}\n","// https://www.ecma-international.org/ecma-262/9.0/index.html#sec-html-like-comments\n// explains that JavaScript parsers may or may not recognize html\n// comment tokens \"<\" immediately followed by \"!--\" and \"--\"\n// immediately followed by \">\" in non-module source text, and treat\n// them as a kind of line comment. Since otherwise both of these can\n// appear in normal JavaScript source code as a sequence of operators,\n// we have the terrifying possibility of the same source code parsing\n// one way on one correct JavaScript implementation, and another way\n// on another.\n//\n// This shim takes the conservative strategy of just rejecting source\n// text that contains these strings anywhere. Note that this very\n// source file is written strangely to avoid mentioning these\n// character strings explicitly.\n\n// We do not write the regexp in a straightforward way, so that an\n// apparennt html comment does not appear in this file. Thus, we avoid\n// rejection by the overly eager rejectDangerousSources.\n// const htmlCommentPattern = new RegExp(`(?:${'<'}!--|--${'>'})`);\n\nfunction rejectHtmlComments() {\n  // const index = s.search(htmlCommentPattern);\n  // if (index !== -1) {\n  //   const linenum = s.slice(0, index).split('\\n').length; // more or less\n  //   throw new SyntaxError(\n  //     `possible html comment syntax rejected around line ${linenum}`\n  //   );\n  // }\n}\n\n// The proposed dynamic import expression is the only syntax currently\n// proposed, that can appear in non-module JavaScript code, that\n// enables direct access to the outside world that cannot be\n// surpressed or intercepted without parsing and rewriting. Instead,\n// this shim conservatively rejects any source text that seems to\n// contain such an expression. To do this safely without parsing, we\n// must also reject some valid programs, i.e., those containing\n// apparent import expressions in literal strings or comments.\n\n// The current conservative rule looks for the identifier \"import\"\n// followed by either an open paren or something that looks like the\n// beginning of a comment. We assume that we do not need to worry\n// about html comment syntax because that was already rejected by\n// rejectHtmlComments.\n\n// this \\s *must* match all kinds of syntax-defined whitespace. If e.g.\n// U+2028 (LINE SEPARATOR) or U+2029 (PARAGRAPH SEPARATOR) is treated as\n// whitespace by the parser, but not matched by /\\s/, then this would admit\n// an attack like: import\\u2028('power.js') . We're trying to distinguish\n// something like that from something like importnotreally('power.js') which\n// is perfectly safe.\n\nconst importPattern = /\\bimport\\s*(?:\\(|\\/[/*])/;\n\nfunction rejectImportExpressions(s) {\n  const index = s.search(importPattern);\n  if (index !== -1) {\n    const linenum = s.slice(0, index).split('\\n').length; // more or less\n    throw new SyntaxError(\n      `possible import expression rejected around line ${linenum}`\n    );\n  }\n}\n\n// The shim cannot correctly emulate a direct eval as explained at\n// https://github.com/Agoric/realms-shim/issues/12\n// Without rejecting apparent direct eval syntax, we would\n// accidentally evaluate these with an emulation of indirect eval. Tp\n// prevent future compatibility problems, in shifting from use of the\n// shim to genuine platform support for the proposal, we should\n// instead statically reject code that seems to contain a direct eval\n// expression.\n//\n// As with the dynamic import expression, to avoid a full parse, we do\n// this approximately with a regexp, that will also reject strings\n// that appear safely in comments or strings. Unlike dynamic import,\n// if we miss some, this only creates future compat problems, not\n// security problems. Thus, we are only trying to catch innocent\n// occurrences, not malicious one. In particular, `(eval)(...)` is\n// direct eval syntax that would not be caught by the following regexp.\n\nconst someDirectEvalPattern = /\\beval\\s*(?:\\(|\\/[/*])/;\n\nfunction rejectSomeDirectEvalExpressions(s) {\n  const index = s.search(someDirectEvalPattern);\n  if (index !== -1) {\n    const linenum = s.slice(0, index).split('\\n').length; // more or less\n    throw new SyntaxError(\n      `possible direct eval expression rejected around line ${linenum}`\n    );\n  }\n}\n\nexport function rejectDangerousSources(s) {\n  rejectHtmlComments(s);\n  rejectImportExpressions(s);\n  rejectSomeDirectEvalExpressions(s);\n}\n\n// Export a rewriter transform.\nexport const rejectDangerousSourcesTransform = {\n  rewrite(rs) {\n    rejectDangerousSources(rs.src);\n    return rs;\n  }\n};\n","// Portions adapted from V8 - Copyright 2016 the V8 project authors.\n// https://github.com/v8/v8/blob/master/src/builtins/builtins-function.cc\n\nimport {\n  apply,\n  arrayJoin,\n  arrayPop,\n  create,\n  defineProperties,\n  getOwnPropertyDescriptors,\n  getPrototypeOf,\n  regexpTest,\n  setPrototypeOf,\n  stringIncludes\n} from './commons';\nimport { getOptimizableGlobals } from './optimizer';\nimport { createScopeHandler } from './scopeHandler';\nimport { rejectDangerousSourcesTransform } from './sourceParser';\nimport { assert, throwTantrum } from './utilities';\n\nfunction buildOptimizer(constants) {\n  // No need to build an oprimizer when there are no constants.\n  if (constants.length === 0) return '';\n  // Use 'this' to avoid going through the scope proxy, which is unecessary\n  // since the optimizer only needs references to the safe global.\n  return `const {${arrayJoin(constants, ',')}} = this;`;\n}\n\nfunction createScopedEvaluatorFactory(unsafeRec, constants) {\n  const { unsafeFunction } = unsafeRec;\n\n  const optimizer = buildOptimizer(constants);\n\n  // Create a function in sloppy mode, so that we can use 'with'. It returns\n  // a function in strict mode that evaluates the provided code using direct\n  // eval, and thus in strict mode in the same scope. We must be very careful\n  // to not create new names in this scope\n\n  // 1: we use 'with' (around a Proxy) to catch all free variable names. The\n  // first 'arguments[0]' holds the Proxy which safely wraps the safeGlobal\n  // 2: 'optimizer' catches common variable names for speed\n  // 3: The inner strict function is effectively passed two parameters:\n  //    a) its arguments[0] is the source to be directly evaluated.\n  //    b) its 'this' is the this binding seen by the code being\n  //       directly evaluated.\n\n  // everything in the 'optimizer' string is looked up in the proxy\n  // (including an 'arguments[0]', which points at the Proxy). 'function' is\n  // a keyword, not a variable, so it is not looked up. then 'eval' is looked\n  // up in the proxy, that's the first time it is looked up after\n  // useUnsafeEvaluator is turned on, so the proxy returns the real the\n  // unsafeEval, which satisfies the IsDirectEvalTrap predicate, so it uses\n  // the direct eval and gets the lexical scope. The second 'arguments[0]' is\n  // looked up in the context of the inner function. The *contents* of\n  // arguments[0], because we're using direct eval, are looked up in the\n  // Proxy, by which point the useUnsafeEvaluator switch has been flipped\n  // back to 'false', so any instances of 'eval' in that string will get the\n  // safe evaluator.\n\n  return unsafeFunction(`\n    with (arguments[0]) {\n      ${optimizer}\n      return function() {\n        'use strict';\n        return eval(arguments[0]);\n      };\n    }\n  `);\n}\n\nexport function createSafeEvaluatorFactory(\n  unsafeRec,\n  safeGlobal,\n  transforms,\n  sloppyGlobals\n) {\n  const { unsafeFunction } = unsafeRec;\n\n  const scopeHandler = createScopeHandler(unsafeRec, safeGlobal, sloppyGlobals);\n  const constants = getOptimizableGlobals(safeGlobal);\n  const scopedEvaluatorFactory = createScopedEvaluatorFactory(\n    unsafeRec,\n    constants\n  );\n\n  function factory(endowments = {}, options = {}) {\n    const localTransforms = options.transforms || [];\n    const realmTransforms = transforms || [];\n\n    const mandatoryTransforms = [rejectDangerousSourcesTransform];\n    const allTransforms = [\n      ...localTransforms,\n      ...realmTransforms,\n      ...mandatoryTransforms\n    ];\n\n    // We use the the concise method syntax to create an eval without a\n    // [[Construct]] behavior (such that the invocation \"new eval()\" throws\n    // TypeError: eval is not a constructor\"), but which still accepts a\n    // 'this' binding.\n    const safeEval = {\n      eval(src) {\n        src = `${src}`;\n        // Rewrite the source, threading through rewriter state as necessary.\n        const rewriterState = allTransforms.reduce(\n          (rs, transform) => (transform.rewrite ? transform.rewrite(rs) : rs),\n          { src, endowments }\n        );\n        src = rewriterState.src;\n\n        const scopeTarget = create(\n          safeGlobal,\n          getOwnPropertyDescriptors(rewriterState.endowments)\n        );\n        const scopeProxy = new Proxy(scopeTarget, scopeHandler);\n        const scopedEvaluator = apply(scopedEvaluatorFactory, safeGlobal, [\n          scopeProxy\n        ]);\n\n        scopeHandler.allowUnsafeEvaluatorOnce();\n        let err;\n        try {\n          // Ensure that \"this\" resolves to the safe global.\n          return apply(scopedEvaluator, safeGlobal, [src]);\n        } catch (e) {\n          // stash the child-code error in hopes of debugging the internal failure\n          err = e;\n          throw e;\n        } finally {\n          // belt and suspenders: the proxy switches this off immediately after\n          // the first access, but if that's not the case we abort.\n          if (scopeHandler.unsafeEvaluatorAllowed()) {\n            throwTantrum('handler did not revoke useUnsafeEvaluator', err);\n          }\n        }\n      }\n    }.eval;\n\n    // safeEval's prototype is currently the primal realm's\n    // Function.prototype, which we must not let escape. To make 'eval\n    // instanceof Function' be true inside the realm, we need to point it at\n    // the RootRealm's value.\n\n    // Ensure that eval from any compartment in a root realm is an instance\n    // of Function in any compartment of the same root realm.\n    setPrototypeOf(safeEval, unsafeFunction.prototype);\n\n    assert(getPrototypeOf(safeEval).constructor !== Function, 'hide Function');\n    assert(\n      getPrototypeOf(safeEval).constructor !== unsafeFunction,\n      'hide unsafeFunction'\n    );\n\n    // note: be careful to not leak our primal Function.prototype by setting\n    // this to a plain arrow function. Now that we have safeEval, use it.\n    defineProperties(safeEval, {\n      toString: {\n        // We break up the following literal string so that an\n        // apparent direct eval syntax does not appear in this\n        // file. Thus, we avoid rejection by the overly eager\n        // rejectDangerousSources.\n        value: safeEval(\"() => 'function eval' + '() { [shim code] }'\"),\n        writable: false,\n        enumerable: false,\n        configurable: true\n      }\n    });\n\n    return safeEval;\n  }\n\n  return factory;\n}\n\nexport function createSafeEvaluator(safeEvaluatorFactory) {\n  return safeEvaluatorFactory();\n}\n\nexport function createSafeEvaluatorWhichTakesEndowments(safeEvaluatorFactory) {\n  return (x, endowments, options = {}) =>\n    safeEvaluatorFactory(endowments, options)(x);\n}\n\n/**\n * A safe version of the native Function which relies on\n * the safety of evalEvaluator for confinement.\n */\nexport function createFunctionEvaluator(unsafeRec, safeEval) {\n  const { unsafeFunction, unsafeGlobal } = unsafeRec;\n\n  const safeFunction = function Function(...params) {\n    const functionBody = `${arrayPop(params) || ''}`;\n    let functionParams = `${arrayJoin(params, ',')}`;\n    if (!regexpTest(/^[\\w\\s,]*$/, functionParams)) {\n      throw new unsafeGlobal.SyntaxError(\n        'shim limitation: Function arg must be simple ASCII identifiers, possibly separated by commas: no default values, pattern matches, or non-ASCII parameter names'\n      );\n      // this protects against Matt Austin's clever attack:\n      // Function(\"arg=`\", \"/*body`){});({x: this/**/\")\n      // which would turn into\n      //     (function(arg=`\n      //     /*``*/){\n      //      /*body`){});({x: this/**/\n      //     })\n      // which parses as a default argument of `\\n/*``*/){\\n/*body` , which\n      // is a pair of template literals back-to-back (so the first one\n      // nominally evaluates to the parser to use on the second one), which\n      // can't actually execute (because the first literal evals to a string,\n      // which can't be a parser function), but that doesn't matter because\n      // the function is bypassed entirely. When that gets evaluated, it\n      // defines (but does not invoke) a function, then evaluates a simple\n      // {x: this} expression, giving access to the safe global.\n    }\n\n    // Is this a real functionBody, or is someone attempting an injection\n    // attack? This will throw a SyntaxError if the string is not actually a\n    // function body. We coerce the body into a real string above to prevent\n    // someone from passing an object with a toString() that returns a safe\n    // string the first time, but an evil string the second time.\n    // eslint-disable-next-line no-new, new-cap\n    new unsafeFunction(functionBody);\n\n    if (stringIncludes(functionParams, ')')) {\n      // If the formal parameters string include ) - an illegal\n      // character - it may make the combined function expression\n      // compile. We avoid this problem by checking for this early on.\n\n      // note: v8 throws just like this does, but chrome accepts\n      // e.g. 'a = new Date()'\n      throw new unsafeGlobal.SyntaxError(\n        'shim limitation: Function arg string contains parenthesis'\n      );\n      // todo: shim integrity threat if they change SyntaxError\n    }\n\n    // todo: check to make sure this .length is safe. markm says safe.\n    if (functionParams.length > 0) {\n      // If the formal parameters include an unbalanced block comment, the\n      // function must be rejected. Since JavaScript does not allow nested\n      // comments we can include a trailing block comment to catch this.\n      functionParams += '\\n/*``*/';\n    }\n\n    const src = `(function(${functionParams}){\\n${functionBody}\\n})`;\n\n    return safeEval(src);\n  };\n\n  // Ensure that Function from any compartment in a root realm can be used\n  // with instance checks in any compartment of the same root realm.\n  setPrototypeOf(safeFunction, unsafeFunction.prototype);\n\n  assert(\n    getPrototypeOf(safeFunction).constructor !== Function,\n    'hide Function'\n  );\n  assert(\n    getPrototypeOf(safeFunction).constructor !== unsafeFunction,\n    'hide unsafeFunction'\n  );\n\n  defineProperties(safeFunction, {\n    // Ensure that any function created in any compartment in a root realm is an\n    // instance of Function in any compartment of the same root ralm.\n    prototype: { value: unsafeFunction.prototype },\n\n    // Provide a custom output without overwriting the\n    // Function.prototype.toString which is called by some third-party\n    // libraries.\n    toString: {\n      value: safeEval(\"() => 'function Function() { [shim code] }'\"),\n      writable: false,\n      enumerable: false,\n      configurable: true\n    }\n  });\n\n  return safeFunction;\n}\n","import { createRealmFacade, buildChildRealm } from './realmFacade';\nimport { createNewUnsafeRec, createCurrentUnsafeRec } from './unsafeRec';\nimport {\n  createSafeEvaluatorFactory,\n  createSafeEvaluator,\n  createSafeEvaluatorWhichTakesEndowments,\n  createFunctionEvaluator\n} from './evaluators';\nimport { assert } from './utilities';\nimport { create, defineProperties, freeze, arrayConcat } from './commons';\n\n// Mimic private members on the realm instances.\n// We define it in the same module and do not export it.\nconst RealmRecForRealmInstance = new WeakMap();\n\nfunction getRealmRecForRealmInstance(realm) {\n  // Detect non-objects.\n  assert(Object(realm) === realm, 'bad object, not a Realm instance');\n  // Realm instance has no realmRec. Should not proceed.\n  assert(RealmRecForRealmInstance.has(realm), 'Realm instance has no record');\n\n  return RealmRecForRealmInstance.get(realm);\n}\n\nfunction registerRealmRecForRealmInstance(realm, realmRec) {\n  // Detect non-objects.\n  assert(Object(realm) === realm, 'bad object, not a Realm instance');\n  // Attempt to change an existing realmRec on a realm instance. Should not proceed.\n  assert(\n    !RealmRecForRealmInstance.has(realm),\n    'Realm instance already has a record'\n  );\n\n  RealmRecForRealmInstance.set(realm, realmRec);\n}\n\n// Initialize the global variables for the new Realm.\nfunction setDefaultBindings(safeGlobal, safeEval, safeFunction) {\n  defineProperties(safeGlobal, {\n    eval: {\n      value: safeEval,\n      writable: true,\n      configurable: true\n    },\n    Function: {\n      value: safeFunction,\n      writable: true,\n      configurable: true\n    }\n  });\n}\n\nfunction createRealmRec(unsafeRec, transforms, sloppyGlobals) {\n  const { sharedGlobalDescs, unsafeGlobal } = unsafeRec;\n\n  const safeGlobal = create(unsafeGlobal.Object.prototype, sharedGlobalDescs);\n\n  const safeEvaluatorFactory = createSafeEvaluatorFactory(\n    unsafeRec,\n    safeGlobal,\n    transforms,\n    sloppyGlobals\n  );\n  const safeEval = createSafeEvaluator(safeEvaluatorFactory);\n  const safeEvalWhichTakesEndowments = createSafeEvaluatorWhichTakesEndowments(\n    safeEvaluatorFactory\n  );\n  const safeFunction = createFunctionEvaluator(unsafeRec, safeEval);\n\n  setDefaultBindings(safeGlobal, safeEval, safeFunction);\n\n  const realmRec = freeze({\n    safeGlobal,\n    safeEval,\n    safeEvalWhichTakesEndowments,\n    safeFunction\n  });\n\n  return realmRec;\n}\n\n/**\n * A root realm uses a fresh set of new intrinics. Here we first create\n * a new unsafe record, which inherits the shims. Then we proceed with\n * the creation of the realm record, and we apply the shims.\n */\nfunction initRootRealm(parentUnsafeRec, self, options) {\n  // note: 'self' is the instance of the Realm.\n\n  // todo: investigate attacks via Array.species\n  // todo: this accepts newShims='string', but it should reject that\n  const { shims: newShims, transforms, sloppyGlobals, errorHandler } = options;\n  const allShims = arrayConcat(parentUnsafeRec.allShims, newShims);\n\n  // The unsafe record is created already repaired.\n  const unsafeRec = createNewUnsafeRec(allShims);\n\n  const { unsafeGlobal } = unsafeRec;\n  unsafeGlobal.addEventListener('error', err => {\n    if (errorHandler) errorHandler(err);\n  });\n\n  // eslint-disable-next-line no-use-before-define\n  const Realm = createRealmFacade(unsafeRec, BaseRealm);\n\n  // Add a Realm descriptor to sharedGlobalDescs, so it can be defined onto the\n  // safeGlobal like the rest of the globals.\n  unsafeRec.sharedGlobalDescs.Realm = {\n    value: Realm,\n    writable: true,\n    configurable: true\n  };\n\n  // Creating the realmRec provides the global object, eval() and Function()\n  // to the realm.\n  const realmRec = createRealmRec(unsafeRec, transforms, sloppyGlobals);\n\n  // Apply all shims in the new RootRealm. We don't do this for compartments.\n  const { safeEvalWhichTakesEndowments } = realmRec;\n  for (const shim of allShims) {\n    safeEvalWhichTakesEndowments(shim);\n  }\n\n  // The realmRec acts as a private field on the realm instance.\n  registerRealmRecForRealmInstance(self, realmRec);\n}\n\n/**\n * A compartment shares the intrinsics of its root realm. Here, only a\n * realmRec is necessary to hold the global object, eval() and Function().\n */\nfunction initCompartment(unsafeRec, self, options = {}) {\n  // note: 'self' is the instance of the Realm.\n\n  const { transforms, sloppyGlobals } = options;\n  const realmRec = createRealmRec(unsafeRec, transforms, sloppyGlobals);\n\n  // The realmRec acts as a private field on the realm instance.\n  registerRealmRecForRealmInstance(self, realmRec);\n}\n\nfunction getRealmGlobal(self) {\n  const { safeGlobal } = getRealmRecForRealmInstance(self);\n  return safeGlobal;\n}\n\nfunction realmEvaluate(self, x, endowments = {}, options = {}) {\n  // todo: don't pass in primal-realm objects like {}, for safety. OTOH its\n  // properties are copied onto the new global 'target'.\n  // todo: figure out a way to membrane away the contents to safety.\n  const { safeEvalWhichTakesEndowments } = getRealmRecForRealmInstance(self);\n  return safeEvalWhichTakesEndowments(x, endowments, options);\n}\n\nconst BaseRealm = {\n  initRootRealm,\n  initCompartment,\n  getRealmGlobal,\n  realmEvaluate\n};\n\n// Create the current unsafeRec from the current \"primal\" environment (the realm\n// where the Realm shim is loaded and executed).\nconst currentUnsafeRec = createCurrentUnsafeRec();\n\n/**\n * The \"primal\" realm class is defined in the current \"primal\" environment,\n * and is part of the shim. There is no need to facade this class via evaluation\n * because both share the same intrinsics.\n */\nconst Realm = buildChildRealm(currentUnsafeRec, BaseRealm);\n\nexport default Realm;\n"],"names":["throwTantrum","s","err","msg","console","error","stack","assert","condition","message","cleanupSource","src","buildChildRealm","unsafeRec","BaseRealm","callAndWrapError","target","args","Object","eName","eMessage","eStack","name","ignored","Error","ErrorConstructor","errorConstructors","get","err2","initRootRealm","initCompartment","getRealmGlobal","realmEvaluate","create","defineProperties","Map","EvalError","RangeError","ReferenceError","SyntaxError","TypeError","URIError","Realm","constructor","makeRootRealm","options","r","prototype","makeCompartment","global","evaluate","x","endowments","toString","value","writable","enumerable","configurable","buildChildRealmString","createRealmFacade","unsafeEval","assign","freeze","getOwnPropertyDescriptor","getOwnPropertyDescriptors","getOwnPropertyNames","getPrototypeOf","setPrototypeOf","apply","ownKeys","Reflect","uncurryThis","fn","thisArg","objectHasOwnProperty","hasOwnProperty","arrayFilter","Array","filter","arrayPop","pop","arrayJoin","join","arrayConcat","concat","regexpTest","RegExp","test","stringIncludes","String","includes","frozenGlobalPropertyNames","stableGlobalPropertyNames","unstableGlobalPropertyNames","getSharedGlobalDescs","unsafeGlobal","describe","names","desc","descriptors","repairAccessors","toObject","obj","asPropertyName","aFunction","accessor","defineProperty","objectPrototype","__lookupGetter__","ignore","__defineGetter__","prop","func","O","__defineSetter__","set","__lookupSetter__","repairFunctions","repairFunction","declaration","FunctionInstance","eval","e","FunctionPrototype","TamedFunction","Function","unsafeGlobalSrc","unsafeGlobalEvalSrc","createNewUnsafeGlobalForNode","isNode","vm","require","runInNewContext","createNewUnsafeGlobalForBrowser","document","iframe","createElement","style","display","body","appendChild","contentWindow","getNewUnsafeGlobal","newUnsafeGlobalForBrowser","newUnsafeGlobalForNode","createUnsafeRec","allShims","sharedGlobalDescs","unsafeFunction","repairAccessorsShim","repairFunctionsShim","createNewUnsafeRec","createCurrentUnsafeRec","identifierPattern","keywords","Set","getOptimizableGlobals","safeGlobal","descs","constants","has","alwaysThrowHandler","Proxy","createScopeHandler","sloppyGlobals","useUnsafeEvaluator","__proto__","allowUnsafeEvaluatorOnce","unsafeEvaluatorAllowed","Symbol","unscopables","importPattern","rejectImportExpressions","index","search","linenum","slice","split","length","someDirectEvalPattern","rejectSomeDirectEvalExpressions","rejectDangerousSources","rejectDangerousSourcesTransform","rewrite","rs","buildOptimizer","createScopedEvaluatorFactory","optimizer","createSafeEvaluatorFactory","transforms","scopeHandler","scopedEvaluatorFactory","localTransforms","allTransforms","safeEval","rewriterState","reduce","transform","scopeTarget","scopeProxy","scopedEvaluator","createSafeEvaluator","safeEvaluatorFactory","createSafeEvaluatorWhichTakesEndowments","createFunctionEvaluator","safeFunction","params","functionBody","functionParams","RealmRecForRealmInstance","WeakMap","getRealmRecForRealmInstance","realm","registerRealmRecForRealmInstance","realmRec","setDefaultBindings","createRealmRec","safeEvalWhichTakesEndowments","parentUnsafeRec","self","shims","newShims","errorHandler","addEventListener","shim","currentUnsafeRec"],"mappings":"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"}